#!/opt/bin/perl

# almost every "if" or "?" in this file indicates a place where the OpenCL
# designers fucked it up - each time you have to remember an exception to
# the naming rules.

use common::sense;

my %classmap = qw(
   platform          Platform
   device            Device
   context           Context
   event             Event
   profiling         Event
   mem               Memory
   image             Image
   sampler           Sampler
   program           Program
   program_build     Program
   kernel            Kernel
   kernel_work_group Kernel
   command_queue     Queue
);

my %typemap = (
   cl_bool         => ['cl_bool', 'value [i] ? &PL_sv_yes : &PL_sv_no', 'boolean'],
   #char            => ['char', 'newSVpvn (value, size)', 'string'],
   char            => ['char', 'newSVpv (value, 0)', 'string'], # all these are 0-terminated strings, and the driver often appends a \0
   size_t          => ['size_t', 'newSVuv (value [i])', 'int'],
   "void*"         => ['void *', 'newSVuv ((IV)(intptr_t)value [i])', 'ptr_value'],
   cl_platform_id  => ['cl_platform_id', 'OpenCL::Platform'],
   Context         => ['cl_context', 'OpenCL::Context', 'ctx'],
   Device          => ['cl_device_id', 'OpenCL::Device', 'device'],
   cl_device_id    => ['cl_device_id', 'OpenCL::Device', 'device'],
   Memory          => ['cl_mem', 'OpenCL::Memory', 'mem'],
   Program         => ['cl_program', 'OpenCL::Program', 'program'],
   CommandQueue    => ['cl_command_queue', 'OpenCL::Queue', 'queue'],
   cl_context_properties => ['cl_context_properties', 'newSVuv ((UV)value [i])', 'property_int'],
);

{
   my %tmap = (
      T_IV => "newSViv (value [i])",
      T_UV => "newSVuv (value [i])",
   );

   open my $fh, "<typemap"
      or die "typemap: $!";

   while (<$fh>) {
      next if /^INPUT$/;
      my ($name, $type) = split /\s+/, $_;
      if ($tmap{$type}) {
         $typemap{$name} = [$name, $tmap{$type}, substr $name, 3];
      }
   }
}

sub patch($$$$) {
   my ($file, $beg, $end, $contents) = @_;

   {
      local $/;

      open my $fh, "<$file"
         or die "$file: $!";

      my $data = <$fh>;
      $data =~ s/^(\Q$beg\E\n).*?\n(\Q$end\E\n)/$1\n$contents$2/sm
         or die "$file: couldn't find $beg/$end";

      open my $fh2, ">$file~"
         or die "$file~: $!";

      syswrite $fh2, $data;
   }

   rename "$file~", $file;
}

for my $CLASS (qw(platform device context command_queue mem image sampler program program_build kernel kernel_work_group event profiling)) {
   open my $fh, "<getinfo.txt"
      or die "getinfo.txt: $!";

   my $XS;
   my $POD;

   while (<$fh>) {
      chomp;
      my ($class, $name, $ctype) = split /,\s*/, $_, 3;
      next unless $class eq "cl_$CLASS\_info";
      next if $name eq "CL_IMAGE_FORMAT"; # struct
      next if $name eq "CL_PROGRAM_BINARIES"; # needs multiple calls

      $ctype =~ s/cl:://g;
      $ctype =~ s/::size_t/size_t/g;

      my $cbase = $class;
      $cbase =~ s/_(.)/\U$1/g;
      $cbase =~ s/^cl//;
      $cbase =~ s/Info$//;
      $cbase = "MemObject"      if $cbase eq "Mem";
      $cbase = "EventProfiling" if $cbase eq "Profiling";

      my $real_class = $CLASS;
      $real_class = "program" if $real_class eq "program_build";
      $real_class = "kernel"  if $real_class eq "kernel_work_group";
      $real_class = "event"   if $real_class eq "profiling";

      my $perl_name = lc $name;
      $perl_name =~ s/^cl_//;
      $perl_name =~ s/^$real_class\_//;
      $perl_name =~ s/^queue\_//;

      my $extra_args;
      my $extra_perl_args;
      my $extra_xs_args;

      if ($CLASS eq "program_build" || $CLASS eq "kernel_work_group") {
         $extra_args      = ', device';
         $extra_perl_args = ' ($device)';
         $extra_xs_args   = ', OpenCL::Device device';
      }

      my $dynamic;
      my $nelem = "size / sizeof (value [0])";

      if ($ctype eq "STRING_CLASS") {
         $ctype   = "VECTOR_CLASS<char>";
         $nelem   = "1";
         $dynamic = 1;
      }

      my $type = $ctype;
      my $array = 0;

      if ($type =~ s/^VECTOR_CLASS<\s*(.*)>$/$1/) {
         $dynamic = 1;
         $array   = 1;
      } elsif ($type =~ s/<(\d+)>$//) {
         $dynamic = 1;
         $array   = 1;
      }

      $type = $typemap{$type}
         or die "$name: no mapping for $ctype";

      my $perltype = $type->[2];

      if ($array && $nelem ne "1") {
         $perltype = "\@${perltype}s";
      } else {
         $perltype = "\$$perltype";
      }

      $POD .= "\n=item $perltype = \$$real_class->$perl_name$extra_perl_args\n\nCalls C<clGet${cbase}Info> with C<$name> and returns the result(s).\n";

      $XS .= "void\n"
           . "$perl_name (OpenCL::$classmap{$real_class} this$extra_xs_args)\n"
           . " PPCODE:\n";

      if ($dynamic) {
        $XS .= " size_t size;\n"
             . " NEED_SUCCESS (Get${cbase}Info, (this$extra_args, $name,    0,     0, &size));\n"
             . " $type->[0] *value = tmpbuf (size);\n"
             . " NEED_SUCCESS (Get${cbase}Info, (this$extra_args, $name, size, value,     0));\n";
      } else {
        $XS .= " $type->[0] value [1];\n"
             . " NEED_SUCCESS (Get${cbase}Info, (this$extra_args, $name, sizeof (value), value, 0));\n";
      }
      
      if ($array) {
         $XS .= " int i, n = $nelem;\n"
              . " EXTEND (SP, n);\n"
              . " for (i = 0; i < n; ++i)\n";
      } else {
         $XS .= " EXTEND (SP, 1);\n"
              . " const int i = 0;\n"
      }

      if ($type->[1] =~ /^OpenCL::(\S+)$/) {
         my $oclass = $1;
         $oclass = "MemObject"    if $oclass eq "Memory";
         $oclass = "CommandQueue" if $oclass eq "Queue";

         $XS .= " {\n";
         $XS .= "   NEED_SUCCESS (Retain$oclass, (value [i]));\n" unless $1 eq "Platform" || $1 eq "Device";
         $XS .= "   PUSHs (NEW_MORTAL_OBJ (\"$type->[1]\", value [i]));\n";
         $XS .= " }\n";
      } else {
         $XS .= " PUSHs (sv_2mortal ($type->[1]));\n";
      }

      $XS .= "\n";
   }

   print $XS;

   patch "OpenCL.xs", "#BEGIN:$CLASS"               , "#END:$CLASS"               , $XS;
   patch "OpenCL.pm", "=for gengetinfo begin $CLASS", "=for gengetinfo end $CLASS", "$POD\n";
}

